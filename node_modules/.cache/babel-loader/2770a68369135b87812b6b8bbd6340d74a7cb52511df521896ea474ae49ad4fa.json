{"ast":null,"code":"import { LngLat, Point } from 'mapbox-gl';\nexport var anchors = ['center', 'top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];\nexport var anchorTranslates = {\n  center: 'translate(-50%, -50%)',\n  top: 'translate(-50%, 0)',\n  left: 'translate(0, -50%)',\n  right: 'translate(-100%, -50%)',\n  bottom: 'translate(-50%, -100%)',\n  'top-left': 'translate(0, 0)',\n  'top-right': 'translate(-100%, 0)',\n  'bottom-left': 'translate(0, -100%)',\n  'bottom-right': 'translate(-100%, -100%)'\n};\nvar defaultElement = {\n  offsetWidth: 0,\n  offsetHeight: 0\n};\nvar defaultPoint = [0, 0];\nvar projectCoordinates = function (map, coordinates) {\n  return map.project(LngLat.convert(coordinates));\n};\nvar calculateAnchor = function (map, offsets, position, _a) {\n  var _b = _a === void 0 ? defaultElement : _a,\n    offsetHeight = _b.offsetHeight,\n    offsetWidth = _b.offsetWidth;\n  var anchor = [];\n  if (position.y + offsets.bottom.y - offsetHeight < 0) {\n    anchor = [anchors[1]];\n  } else if (position.y + offsets.top.y + offsetHeight > map.transform.height) {\n    anchor = [anchors[2]];\n  }\n  if (position.x < offsetWidth / 2) {\n    anchor.push(anchors[3]);\n  } else if (position.x > map.transform.width - offsetWidth / 2) {\n    anchor.push(anchors[4]);\n  }\n  if (anchor.length === 0) {\n    return anchors[2];\n  }\n  return anchor.join('-');\n};\nvar normalizedOffsets = function (offset) {\n  if (!offset) {\n    return normalizedOffsets(new Point(0, 0));\n  }\n  if (typeof offset === 'number') {\n    var cornerOffset = Math.round(Math.sqrt(0.5 * Math.pow(offset, 2)));\n    return {\n      center: new Point(offset, offset),\n      top: new Point(0, offset),\n      bottom: new Point(0, -offset),\n      left: new Point(offset, 0),\n      right: new Point(-offset, 0),\n      'top-left': new Point(cornerOffset, cornerOffset),\n      'top-right': new Point(-cornerOffset, cornerOffset),\n      'bottom-left': new Point(cornerOffset, -cornerOffset),\n      'bottom-right': new Point(-cornerOffset, -cornerOffset)\n    };\n  }\n  if (offset instanceof Point || Array.isArray(offset)) {\n    return anchors.reduce(function (res, anchor) {\n      res[anchor] = Point.convert(offset);\n      return res;\n    }, {});\n  }\n  return anchors.reduce(function (res, anchor) {\n    res[anchor] = Point.convert(offset[anchor] || defaultPoint);\n    return res;\n  }, {});\n};\nexport var overlayState = function (props, map, container) {\n  var position = projectCoordinates(map, props.coordinates);\n  var offsets = normalizedOffsets(props.offset);\n  var anchor = props.anchor || calculateAnchor(map, offsets, position, container);\n  return {\n    anchor: anchor,\n    position: position,\n    offset: offsets[anchor]\n  };\n};\nvar moveTranslate = function (point) {\n  return point ? \"translate(\" + point.x.toFixed(0) + \"px, \" + point.y.toFixed(0) + \"px)\" : '';\n};\nexport var overlayTransform = function (_a) {\n  var anchor = _a.anchor,\n    position = _a.position,\n    offset = _a.offset;\n  var res = [];\n  if (position) {\n    res.push(moveTranslate(position));\n  }\n  if (offset && offset.x !== undefined && offset.y !== undefined) {\n    res.push(moveTranslate(offset));\n  }\n  if (anchor) {\n    res.push(anchorTranslates[anchor]);\n  }\n  return res;\n};","map":{"version":3,"names":["LngLat","Point","anchors","anchorTranslates","center","top","left","right","bottom","defaultElement","offsetWidth","offsetHeight","defaultPoint","projectCoordinates","map","coordinates","project","convert","calculateAnchor","offsets","position","_a","_b","anchor","y","transform","height","x","push","width","length","join","normalizedOffsets","offset","cornerOffset","Math","round","sqrt","pow","Array","isArray","reduce","res","overlayState","props","container","moveTranslate","point","toFixed","overlayTransform","undefined"],"sources":["/Users/mikolakondratuk/FossoSushi/node_modules/react-mapbox-gl/src/util/overlays.ts"],"sourcesContent":["import { LngLat, Point, Map } from 'mapbox-gl';\nimport { Props } from '../projected-layer';\nimport { Anchor, AnchorsOffset } from './types';\n\nexport interface PointDef {\n  x: number;\n  y: number;\n}\n\nexport interface OverlayParams {\n  anchor?: Anchor;\n  offset?: Point;\n  position?: Point;\n}\n\nexport const anchors = [\n  'center',\n  'top',\n  'bottom',\n  'left',\n  'right',\n  'top-left',\n  'top-right',\n  'bottom-left',\n  'bottom-right'\n] as Anchor[];\n\nexport const anchorTranslates = {\n  center: 'translate(-50%, -50%)',\n  top: 'translate(-50%, 0)',\n  left: 'translate(0, -50%)',\n  right: 'translate(-100%, -50%)',\n  bottom: 'translate(-50%, -100%)',\n  'top-left': 'translate(0, 0)',\n  'top-right': 'translate(-100%, 0)',\n  'bottom-left': 'translate(0, -100%)',\n  'bottom-right': 'translate(-100%, -100%)'\n};\n\n// Hack /o\\\nconst defaultElement = { offsetWidth: 0, offsetHeight: 0 };\nconst defaultPoint = [0, 0];\n\nconst projectCoordinates = (map: Map, coordinates: [number, number]) =>\n  map.project(LngLat.convert(coordinates));\n\nconst calculateAnchor = (\n  map: Map,\n  offsets: AnchorsOffset,\n  position: PointDef,\n  { offsetHeight, offsetWidth } = defaultElement\n) => {\n  let anchor: string[] = [];\n\n  if (position.y + offsets.bottom.y - offsetHeight < 0) {\n    anchor = [anchors[1]];\n  } else if (\n    position.y + offsets.top.y + offsetHeight >\n    // tslint:disable-next-line:no-any\n    (map as any).transform.height\n  ) {\n    anchor = [anchors[2]];\n  }\n\n  if (position.x < offsetWidth / 2) {\n    anchor.push(anchors[3]);\n    // tslint:disable-next-line:no-any\n  } else if (position.x > (map as any).transform.width - offsetWidth / 2) {\n    anchor.push(anchors[4]);\n  }\n\n  if (anchor.length === 0) {\n    return anchors[2];\n  }\n\n  return anchor.join('-') as Anchor;\n};\n\nconst normalizedOffsets = (\n  offset?: number | Point | AnchorsOffset | [number, number]\n): AnchorsOffset => {\n  if (!offset) {\n    return normalizedOffsets(new Point(0, 0));\n  }\n\n  if (typeof offset === 'number') {\n    // input specifies a radius from which to calculate offsets at all positions\n    const cornerOffset = Math.round(Math.sqrt(0.5 * Math.pow(offset, 2)));\n    return {\n      center: new Point(offset, offset),\n      top: new Point(0, offset),\n      bottom: new Point(0, -offset),\n      left: new Point(offset, 0),\n      right: new Point(-offset, 0),\n      'top-left': new Point(cornerOffset, cornerOffset),\n      'top-right': new Point(-cornerOffset, cornerOffset),\n      'bottom-left': new Point(cornerOffset, -cornerOffset),\n      'bottom-right': new Point(-cornerOffset, -cornerOffset)\n    };\n  }\n\n  if (offset instanceof Point || Array.isArray(offset)) {\n    // input specifies a single offset to be applied to all positions\n    return anchors.reduce(\n      (res, anchor) => {\n        res[anchor] = Point.convert(offset);\n        return res;\n      },\n      // tslint:disable-next-line:no-object-literal-type-assertion\n      {} as AnchorsOffset\n    );\n  }\n\n  // input specifies an offset per position\n  return anchors.reduce(\n    (res, anchor) => {\n      res[anchor] = Point.convert(offset[anchor] || defaultPoint);\n      return res;\n    },\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    {} as AnchorsOffset\n  );\n};\n\nexport const overlayState = (\n  props: Props,\n  map: Map,\n  container: HTMLElement\n) => {\n  const position = projectCoordinates(map, props.coordinates);\n  const offsets = normalizedOffsets(props.offset);\n  const anchor =\n    props.anchor || calculateAnchor(map, offsets, position, container);\n\n  return {\n    anchor,\n    position,\n    offset: offsets[anchor]\n  };\n};\n\nconst moveTranslate = (point: Point) =>\n  point ? `translate(${point.x.toFixed(0)}px, ${point.y.toFixed(0)}px)` : '';\n\nexport const overlayTransform = ({\n  anchor,\n  position,\n  offset\n}: OverlayParams) => {\n  const res = [];\n\n  if (position) {\n    res.push(moveTranslate(position));\n  }\n\n  if (offset && offset.x !== undefined && offset.y !== undefined) {\n    res.push(moveTranslate(offset));\n  }\n\n  if (anchor) {\n    res.push(anchorTranslates[anchor]);\n  }\n\n  return res;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}